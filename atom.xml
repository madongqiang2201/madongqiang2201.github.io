<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小马哥Mark的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://madongqiang2201.github.io/"/>
  <updated>2018-12-02T09:39:13.842Z</updated>
  <id>https://madongqiang2201.github.io/</id>
  
  <author>
    <name>小马哥Mark</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android两种序列化方式详解(一)：Serializable</title>
    <link href="https://madongqiang2201.github.io/2018/12/02/Android%E4%B8%A4%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3-%E4%B8%80-%EF%BC%9ASerializable/"/>
    <id>https://madongqiang2201.github.io/2018/12/02/Android两种序列化方式详解-一-：Serializable/</id>
    <published>2018-12-02T06:35:54.000Z</published>
    <updated>2018-12-02T09:39:13.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Android 开发中，我们经常需要对对象进行序列化与反序列化操作，最常见的就是通过 Intent 传输数据时，Intent 只能传输基本数据类型、String 类型和可序列化与反序列化的对象类型，要想通过 Intent 传递对象类型，我们需要让该对象类型支持序列化和反序列化。</p><p>我们知道，Android 给我们提供了两种方式来完成序列化与反序列化过程：一种是 Serializable 方式，另一种是 Parcelable 方式；本篇文章将详细讲述使用 Serializable 方式实现序列化你所需要知道的一切。</p><p>你可能会疑问，使用 Serializable 实现序列化，不是只要让类实现 Serializable 接口就可以了吗，有什么好讲的？那你就 too naive 了少年！除了基础的直接实现 Serializable 接口之外，我们使用 Serializable 方式实现序列化的过程还有很多需要注意的细节，例如 serialVersionUID 是干什么的呢？如果我们想自定义实现序列化与反序列化过程该怎么办呢？本文将会详细介绍这些知识。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本文讲述的知识点如下：</p><ol><li>怎样序列化与反序列化一个对象</li><li>serialVersionUID 的作用</li><li>如何自定义序列化和反序列化过程</li><li>总结</li></ol><h2 id="一、怎样序列化和反序列化一个对象"><a href="#一、怎样序列化和反序列化一个对象" class="headerlink" title="一、怎样序列化和反序列化一个对象"></a>一、怎样序列化和反序列化一个对象</h2><p>想要序列化和反序列化一个对象，首先要让对象支持序列化与反序列化，使用 Serializable 方式实现序列化相当简单，只需要让类实现 Serializable 接口就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSerial</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>现在 UserSerial 类就支持序列化和反序列化了，那么我们应该怎么将 UserSerial 类的某个对象序列化到文件，然后再将其读取出来呢？当然是使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 啦～</p><p>完整的序列化流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(UserSerial user)</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"temp.txt"</span>));</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的反序列化流程如下，这里为了防止反序列化异常返回 null，默认我们返回了一个新构造的空 UserSerial 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserSerial <span class="title">deserial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"temp.txt"</span>));</span><br><span class="line">        <span class="keyword">return</span>  (UserSerial) in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserSerial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人要吐槽我上面说的都是废话了，上面这些东西，稍微了解点 Java 的都知道啊～没事，且往下看，我们来说一些可能大家使用过程中没注意到的细节。</p><h2 id="serialVersionUID-的作用"><a href="#serialVersionUID-的作用" class="headerlink" title="serialVersionUID 的作用"></a>serialVersionUID 的作用</h2><p>我们在使用 Serializable 方式实现序列化时，除了实现 Serializable 接口之外，一般还需要声明一个 serialVersionUID 静态字段，当然我们也可以选择不声明这个字段，那么我们在使用过程中，要不要指定这个字段呢？如果指定了，这个字段的值又是干什么用的呢？</p><p>其实 serialVersionUID 这个字段，是序列化和反序列化过程中，用来校验类是否发生了变动的依据，序列化的时候系统会把当前类的 serialVersionUID 字段写入序列化的文件中，当反序列化的时候，系统会去检测文件中的 serialVersionUID，看它是否和当前类的 serialVersionUID 一致，如果一致就说明序列化时类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化时的类相比发生了某些变换，比如增删了某些成员变量等，这个时候是无法正常的反序列化的，并且会报 <code>InvalidClassException</code>。</p><p>一般来讲，我们都应该手动指定 serialVersionUID 的值，可以随意指定一个数字，或者根据编辑器提示自动根据当前类的结构生成 hash 值，这样如果我们不手动修改，序列化和反序列化过程中 serialVersionUID 字段的值一直都会是一致的，可以最大限度的保证反序列化过程的成功，就算类结构发生了变动，我们也可以保证那些没有发生变动的成员变量被成功的反序列化。如果我们不手动指定 serialVersionUID 字段的值，那么如果反序列化时相比序列化时的类结构发生了变动，比如增删了成员变量等，那么系统就会重新计算当前类的 hash 值，并将其赋值给 serialVersionUID，导致序列化时的类和当前类的 serialVersionUID 值不一致，导致反序列化失败，从而 crash。</p><p>最后要说明的是，如果类结构发生了毁灭性的变化，如类名、成员变量类型等发生了改变，这个时候就算 serialVersionUID 值一致，也是不能被正常反序列化的，这一点后面还会提到。</p><h2 id="如何自定义序列化和反序列化过程"><a href="#如何自定义序列化和反序列化过程" class="headerlink" title="如何自定义序列化和反序列化过程"></a>如何自定义序列化和反序列化过程</h2><p>现在我们知道如果一个类，实现了 Serializable 接口，那么在需要的时候，自动完成该类的序列化，与反序列化过程；那么如果我们想自定义序列化过程与反序列化过程该怎么办呢？例如我在版本 1 的时候，将 User 对象的 name 序列化了，但是反序列化的时候，我想把这个这个字段的值赋值给 nameNew，该怎么做到呢？</p><p>第一部分我们我们提到，使用 Serializable 方式实现序列化是，对象的序列化和反序列化过程是通过 <code>ObjectOutputStream.writeObject</code> 和 <code>ObjectInputStream.readObject</code> 实现的，这里以 <code>ObjectOutputStream.writeObject</code> 为例分析，追踪 <code>writeObject</code> 方法代码，发现其内部调用了 writeObject0 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <code>writeObject0</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="comment">// END Android-changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们的对象是 Serializable，所以最终会走到 <code>writeOrdinaryObject</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,ObjectStreamClass desc,<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">        writeExternalData((Externalizable) obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 <code>writeOrdinaryObject</code> 方法内部做了判断，看当前类是实现的 <code>Externalizable</code> 接口还是 <code>Serializable</code> 接口，因为我们是实现的 <code>Serializable</code> 接口，所以最终走到了 <code>writeSerialData</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">走到这里就很明确了，我们发现，在 `ObjectOutputStream.writeObject` 过程中，最终会判断，当前类本身是否 `hasWriteObjectMethod()`。</span><br><span class="line"></span><br><span class="line">如果 `hasWriteObjectMethod()` 为 <span class="keyword">true</span>，就通过反射，调用类自带的方法 `slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);`，点进 `invokeWriteObject` 方法，我们发现内部是通过反射调用的 `writeObjectMethod`，这是一个 `Method` 类型的字段，而给该字段初始化的代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123; ObjectOutputStream.class &#125;, Void.TYPE);</span><br></pre></td></tr></table></figure><p>最后我们发现，是通过反射调用的实现 Serializable 接口的类的 <code>writeObject</code> 方法，而参数类型是 <code>ObjectOutputStream</code> 类型。</p><p>而如果 <code>hasWriteObjectMethod()</code> 为 false，就使用 <code>defaultWriteFields</code> 完成序列化，也就是系统默认的序列化方法，想了解系统默认序列化方法的可以点进源码自己查看。</p><p>通过同样的步骤，我们可以发现 <code>ObjectInputStream.readObject</code> 方法内部，也判断了类是否有 <code>readObject</code> 方法，有就使用类自己的，没有就使用默认的。</p><p>所以如果我们在使用 Serializable 实现序列化与反序列化是，想实现自定义的序列化和反序列化过程，只需要给当前类添加 <code>writeObject</code> 和 <code>readObject</code> 方法即可，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream.PutField putFields = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        putFields = out.putFields();</span><br><span class="line">        putFields.put(<span class="string">"name"</span>, name);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjectInputStream.GetField readFields = in.readFields();</span><br><span class="line">        name = (String) readFields.get(<span class="string">"name"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认真的同学可能还会有一个疑问，那就是为啥你这自己写的 <code>readObject</code> 方法没有返回值呢？这个方法不应该返回一个当前类对象吗，像 <code>ObjectInputStream.readObject</code> 方法一样？这个问题的答案也可以通过查看源码得到解答，其实反序列化过程可以分为两步，一步是通过反射创建类对象的过程，一个是给创建的对象内的变量赋值的过程，而我们重写的方法只是完成了给当前创建的对象复制的过程，是赋给自身变量的，所以没有返回值，对象创建的过程在 <code>ObjectInputStream.readObject</code> 方法内，可通过源码验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上分析，我们可以得出一下结论：</p><ol><li>我们总应该给使用 Serializable 方式实现序列化与反序列化的类指定 serialVersionUID</li><li>我们可以通过给类添加 <code>writeObject(ObjectOutputStream out)</code> 和 <code>readObject(ObjectInputStream in)</code> 方法的方式自定义序列化和反序列化过程</li><li>静态变量和 transient 关键字标注的字段是不参与序列化与反序列化过程的，但是我们仍然可以通过自定义序列化和反序列化的过程打破这个限制，当然也可以通过 Java 提供的另一个序列化接口 <code>Externalizable</code> 来打破这个限制，内部原理差不多</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Android 开发中，我们经常需要对对象进行序列化与反序列化操作，最常见的就是通过 Intent 传输数据时，Intent 只能传输基
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activity的生命周期和启动模式</title>
    <link href="https://madongqiang2201.github.io/2018/10/14/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://madongqiang2201.github.io/2018/10/14/Activity的生命周期和启动模式/</id>
    <published>2018-10-14T06:01:44.000Z</published>
    <updated>2018-10-14T07:07:41.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity-的生命周期和启动模式"><a href="#Activity-的生命周期和启动模式" class="headerlink" title="Activity 的生命周期和启动模式"></a>Activity 的生命周期和启动模式</h1><p>ActivityThread#performLaunchActivity - oncreate、onstart、onrestoreinstancestate、onpostCreate(Called when activity start-up is complete (after {@link #onStart} and {@link #onRestoreInstanceState} have been called).  Applications will generally not implement this method; it is intended for system classes to do final initialization after application code has run.)</p><p>Activity 启动过程中最重要的几个类：Instrumentation、ActivityThread、Activity</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity-的生命周期和启动模式&quot;&gt;&lt;a href=&quot;#Activity-的生命周期和启动模式&quot; class=&quot;headerlink&quot; title=&quot;Activity 的生命周期和启动模式&quot;&gt;&lt;/a&gt;Activity 的生命周期和启动模式&lt;/h1&gt;&lt;p&gt;Ac
      
    
    </summary>
    
      <category term="Android" scheme="https://madongqiang2201.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://madongqiang2201.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
